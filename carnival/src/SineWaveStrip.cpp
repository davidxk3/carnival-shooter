// This code was generated by chatGPT

#include <string>
#include <iostream>
#include <fstream>
#include <vector>
#include <ctime>

#define GLEW_STATIC
#include <GL/glew.h>
#ifdef _WIN32
#include <GL/wglew.h> // For wglSwapInterval
#endif

#define FREEGLUT_STATIC
#include <GL/freeglut.h>

#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/transform.hpp>
#include <glm/gtx/quaternion.hpp>

#include "SineWaveStrip.h"

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/*
* Baseline: change Y_BASE (defaults to 4.0).

Curve: edit Y0, AMP, FREQ.

Smoothness: increase SEG.

Thickness in Z: change Z_HALF (total thickness = 2*Z_HALF).
*/
static const float XMIN = -12.0f;
static const float XMAX = 12.0f;
static const int   SEG = 400;      // longitudinal subdivisions

static const float Y_BASE = 3.0f;   // baseline (bottom of the wall)
// ---------- Curve + Mesh Parameters ----------


// y(x) = Y0 + AMP * sin(FREQ * x), centered at 5.0 as requested
static const float Y0 = 5.0f;
static const float AMP = 1.0f;
static const float FREQ = 1.0f;

// -------- Extrusion in Z --------
static const float Z_CENTER = -6.0f;     // wall center in Z
static const float Z_THICK = 0.5f;      // total thickness
static const float Z_FRONT = (Z_CENTER + 0.5f * Z_THICK); // closer to viewer
static const float Z_BACK = (Z_CENTER - 0.5f * Z_THICK); // farther from viewer


static void v3(float r[3], float x, float y, float z) { r[0] = x; r[1] = y; r[2] = z; }
static float vlen(const float a[3]) { return sqrtf(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]); }
static void vnorm(float r[3], const float a[3]) { float L = vlen(a); if (L > 1e-12f) { r[0] = a[0] / L; r[1] = a[1] / L; r[2] = a[2] / L; } else v3(r, 0, 0, 1); }


static const int   SEGMENTS = 200;    // longitudinal subdivisions

static GLfloat ambient[] = { 0.137f, 0.298f, 0.369f, 1.0f };
static GLfloat diffuse[] = { 0.137f, 0.298, 0.369f, 1.0f };
static GLfloat specular[] = { 0.5f, 0.5f, 0.5f, 1.0f };
static GLfloat shininess[] = { 4.0F };

//Sample curve and derivative

static inline float y_of_x(float x) { return Y0 + AMP * sinf((3.14159265 / 2.0 * (x - XMIN))+ -(3.14159265 / 2.0)); }
static inline float dydx_of_x(float x) { return AMP * FREQ * cosf(FREQ * x); }


static float zoom = 1.0f;
static float zrot = 0.0f;


void drawSineWaveMesh(void)
{
    glMaterialfv(GL_FRONT, GL_AMBIENT, ambient);
    glMaterialfv(GL_FRONT, GL_SPECULAR, specular);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse);
    glMaterialfv(GL_FRONT, GL_SHININESS, shininess);

    float dx = (XMAX - XMIN) / SEG;

    // ----- FRONT FACE -----
    glNormal3f(0,0,1);
    glBegin(GL_TRIANGLE_STRIP);
    for(int i=0;i<=SEG;i++){
        float x = XMIN + i*dx;
        glVertex3f(x, Y_BASE, Z_FRONT);
        glVertex3f(x, y_of_x(x), Z_FRONT);
    }
    glEnd();

    // ----- BACK FACE -----
    glNormal3f(0,0,-1);
    glBegin(GL_TRIANGLE_STRIP);
    for(int i=0;i<=SEG;i++){
        float x = XMIN + i*dx;
        glVertex3f(x, Y_BASE, Z_BACK);
        glVertex3f(x, y_of_x(x), Z_BACK);
    }
    glEnd();

    // ----- TOP RIM -----
    glBegin(GL_TRIANGLE_STRIP);
    for(int i=0;i<=SEG;i++){
        float x = XMIN + i*dx;
        float y = y_of_x(x);
        float dy = dydx_of_x(x);
        // outward normal in XY plane: (-dy/dx, 1, 0)
        float nx = -dy, ny = 1.0f;
        float len = sqrtf(nx*nx + ny*ny);
        nx/=len; ny/=len;
        glNormal3f(nx,ny,0);
        glVertex3f(x, y, Z_FRONT);
        glVertex3f(x, y, Z_BACK);
    }
    glEnd();

    // ----- BASE RIM (y=4) -----
    glNormal3f(0,-1,0);
    glBegin(GL_TRIANGLE_STRIP);
    for(int i=0;i<=SEG;i++){
        float x = XMIN + i*dx;
        glVertex3f(x, Y_BASE, Z_FRONT);
        glVertex3f(x, Y_BASE, Z_BACK);
    }
    glEnd();

    // ----- LEFT CAP (x = XMIN) -----
    glNormal3f(-1,0,0);
    glBegin(GL_QUADS);
    glVertex3f(XMIN, Y_BASE, Z_FRONT);
    glVertex3f(XMIN, y_of_x(XMIN), Z_FRONT);
    glVertex3f(XMIN, y_of_x(XMIN), Z_BACK);
    glVertex3f(XMIN, Y_BASE, Z_BACK);
    glEnd();

    // ----- RIGHT CAP (x = XMAX) -----
    glNormal3f(1,0,0);
    glBegin(GL_QUADS);
    glVertex3f(XMAX, Y_BASE, Z_FRONT);
    glVertex3f(XMAX, y_of_x(XMAX), Z_FRONT);
    glVertex3f(XMAX, y_of_x(XMAX), Z_BACK);
    glVertex3f(XMAX, Y_BASE, Z_BACK);
    glEnd();
}



